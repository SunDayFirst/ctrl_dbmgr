#pragma once
#include <QtSql>
#include <string>

#include "controller_i.h" //for Enum UseLevel

typedef int TObjId;

namespace db
{
/*
 SomenameData: используется для вставки записей в таблицу и получения результатов запросов
 НЕ имеет пустого конструктора - защита от кривых вставок
 Обязательно имеет полный конструктор - для удобства формирования результатов SELECT'а
 Обязательно имеет конструтор от полей, обязательных для заполнения при вставке данных - для INSERT'ов

 SomenameQuery: содержит указатели на атриубты, используется исключительно для формирования условий SELECT'a для таблицы одноименной сущности.
 Обязательно имеет пустой конструктор.
 Обязательно имеет полный конструктор.

{ ActionSO
 ErrorSO
 Traffic
 UserLog } для получения и вставки данных из/в db имеют персональные функции. SelectQueryName в качестве образца для запроса принимает указатель. //может стоить сделать тожк по ссылке? @AU
 В запросе можно указать начало и конец временного интервала.

 Прочие сущности  добавляются и запрашиваются из базы шаблонными функциями SelectQuery и InsertData. SelectQuery в качестве образца для запроса принимает ссылку.

 */


struct ActionSOData;
struct ActionSOQuery; //to set options of query
struct CCPlanData;
struct CCPlanQuery;
struct CCPlanPhaseData;
struct CCPlanPhaseQuery;
struct CCZoneData;
struct CCZoneQuery;
struct CCZoneSOData;
struct CCZoneSOQuery;
struct DetectorData;
struct DetectorQuery;
struct DistrictData;
struct DistrictQuery;
struct ErrorsSOData;
struct ErrorsSOQuery;
struct LogbookData;
struct LogbookQuery;
struct PhaseData;
struct PhaseQuery;
struct PlanData;
struct PlanQuery;
struct PlanPhaseData;
struct PlanPhaseQuery;
struct SOData;
struct SOQuery;
struct SODetectorData;
struct SODetectorQuery;
struct TrafficData;
struct TrafficQuery;
struct UserData;
struct UserQuery;
struct UserLogData;
struct UserLogQuery;

class DbMgr
{
    friend DbMgr& GetDbMgr();
public:
    ~DbMgr(){ sdb_.close(); }
    bool Createdb(std::string& db_path);
    bool Opendb(std::string& db_path);

    bool GetSetting(const std::string& settingName, std::string& settingValue);
    bool InsertSetting(const std::string& settingNameToInsert, const std::string& settingValueToInsert);

    bool InsertActioSO(ActionSOData& actionToInsert);
    bool SelectActionSO(std::vector<ActionSOData>& result, ActionSOQuery* actionToSelect);
    bool InsertErrorSO(ErrorsSOData& errorToInsert);
    bool SelectErrorSO(std::vector<ErrorsSOData>& result, ErrorsSOQuery* errorToSelect);
    bool ResetErrorSO(ErrorsSOQuery* errorToDisable, time_t fixTime);
    bool InsertTraffic(TrafficData& trafficToInsert);
    bool SelectTraffic(std::vector<TrafficData>& result, TrafficQuery* trafficToSelect);
    bool InsertUserLog(UserLogData& userLogToInsert);
    bool SelectUserLog(std::vector<UserLogData>& result, UserLogQuery* userToSelect);

    std::string SoIdToTp(TObjId id);
    TObjId SoIpToTd(std::string soIp);
    template <typename T> bool InsertData(T& structToInsert);
    template <typename D, typename Q> bool SelectQuery(std::vector<D>& result, Q& structToSelect,
                                                        std::string* orderColumn = nullptr, unsigned int limit = 0);
    template <typename Q> bool UpdateData(Q& dataToSet, Q& queryWhere);

    std::string GetLastError() {return lastError_;}

private:
    DbMgr();
    DbMgr(const DbMgr& other);
    DbMgr& operator=(const DbMgr& other);

    bool makeSODictionaries();

    QSqlDatabase sdb_;
    std::string lastError_;
    bool DbMgr::checkQueryError (QSqlQuery& query_to_check, std::string* result);
    std::map<TObjId, std::string> soIdToIp_;
    std::map<std::string, TObjId> soIpToId_;
    std::string check;

   //QSqlDatabase has its own lastError member
};

DbMgr& GetDbMgr();
 
 struct ActionSOData
{
    ActionSOData(time_t actionDatetime, std::string action, TObjId userId,
                 TObjId soId): //it's good enough to send data into db
        id_(0),
        actionDatetime_(actionDatetime),
        action_(action),
        userId_(userId),
        soId_(soId) {}

    ActionSOData(TObjId id, time_t actionDatetime, std::string action, TObjId userId,
                 TObjId soId): //use this constructor for received data only
        id_(id),
        actionDatetime_(actionDatetime),
        action_(action),
        userId_(userId),
        soId_(soId) {}



    TObjId id_; //generated by db; do not touch
    time_t actionDatetime_;
    std::string action_;
    TObjId userId_; //foreighn key on User
    TObjId soId_; //foreign key on SO
};
struct ActionSOQuery //to set options of query
{
    ActionSOQuery(TObjId* pId, time_t* pActionDatetimeStart, time_t* pActionDatetimeEnd, TObjId* pUserId, TObjId* pSoId):
        pId_(pId),
        pActionDatetimeStart_(pActionDatetimeStart),
        pActionDatetimeEnd_(pActionDatetimeEnd),
        pUserId_(pUserId),
        pSoId_(pSoId) {}

    ActionSOQuery():
        pId_(nullptr),
        pActionDatetimeStart_(nullptr),
        pActionDatetimeEnd_(nullptr),
        pUserId_(nullptr),
        pSoId_(nullptr) {}

    TObjId* pId_; //generated by db; do not touch
    time_t* pActionDatetimeStart_;
    time_t* pActionDatetimeEnd_;
    std::string* pAction_;
    TObjId* pUserId_; //foreighn key on User
    TObjId* pSoId_; //foreign key on SO
};

struct CCPlanData
{
    CCPlanData(unsigned int cycleTime ,std::string mapImgUri,
               std::string cycleImgUri, TObjId zoneCCId):
        id_(0),
        cycleTime_(cycleTime),
        mapImgUri_(mapImgUri),
        cycleImgUri_(cycleImgUri),
        ccZoneId_(zoneCCId) {}

    CCPlanData(std::string name, std::string description,
                unsigned int cycleTime, std::string mapImgUri,
               std::string cycleImgUri, TObjId zoneCCId ):
        id_(0),
        name_(name),
        description_(description),
        cycleTime_(cycleTime),
        mapImgUri_(mapImgUri),
        cycleImgUri_(cycleImgUri),
        ccZoneId_(zoneCCId) {}

    CCPlanData(TObjId id, std::string name, std::string description,
                unsigned int cycleTime, std::string mapImgUri,
               std::string cycleImgUri, TObjId zoneCCId ):
        id_(id),
        name_(name),
        description_(description),
        cycleTime_(cycleTime),
        mapImgUri_(mapImgUri),
        cycleImgUri_(cycleImgUri),
        ccZoneId_(zoneCCId) {}

    TObjId id_; //don't touch; generated by db
    std::string name_; //optional atribute; set manually
    std::string description_; //optional atribute; set manually
    unsigned int cycleTime_;
    std::string mapImgUri_;
    std::string cycleImgUri_;
    TObjId ccZoneId_;
};
struct CCPlanQuery
{
    CCPlanQuery():
       pId_(nullptr),
       pName_(nullptr),
       pDescription_(nullptr),
       pCycleTime_(nullptr),
       pMapImgUri_(nullptr),
       pCycleImgUri_(nullptr),
       pZoneCCId_(nullptr) {}

    CCPlanQuery(TObjId* pId, std::string* pName, std::string* pDescription,
                unsigned int* pCycleTime, std::string* pMapImgUri,
                std::string* pCycleImgUri, TObjId* pZoneCCId):
       pId_(pId),
       pName_(pName),
       pDescription_(pDescription),
       pCycleTime_(pCycleTime),
       pMapImgUri_(pMapImgUri),
       pCycleImgUri_(pCycleImgUri),
       pZoneCCId_(pZoneCCId) {}

    TObjId* pId_;
    std::string* pName_;
    std::string* pDescription_;
    unsigned int* pCycleTime_;
    std::string* pMapImgUri_;
    std::string* pCycleImgUri_;
    TObjId* pZoneCCId_;
};

struct CCPlanPhaseData
{
    CCPlanPhaseData(TObjId ccPlanId, TObjId soId, unsigned int phaseNum,
                    unsigned int timeOn):
        ccPlanId_(ccPlanId),
        soId_(soId),
        phaseNum_(phaseNum),
        timeOn_(timeOn) {}

    TObjId ccPlanId_;
    TObjId soId_;
    unsigned int phaseNum_;
    unsigned int timeOn_;
};
struct CCPlanPhaseQuery
{
    CCPlanPhaseQuery():
        pCCPlanId_(nullptr),
        pSoId_(nullptr),
        pPhaseNum_(nullptr),
        pTimeOn_(nullptr) {}

    CCPlanPhaseQuery(TObjId* pCCPlanId, TObjId* pSoId, unsigned int* pPhaseNum,
                     unsigned int* pTimeOn):
        pCCPlanId_(pCCPlanId),
        pSoId_(pSoId),
        pPhaseNum_(pPhaseNum),
        pTimeOn_(pTimeOn) {}


    TObjId* pCCPlanId_;
    TObjId* pSoId_;
    unsigned int* pPhaseNum_;
    unsigned int* pTimeOn_;
};

struct CCZoneData
{
    explicit CCZoneData(std::string name):
        id_(0),
        name_(name) {}
    CCZoneData(std::string name, std::string description):
        id_(0),
        name_(name),
        description_(description) {}

    CCZoneData(TObjId id, std::string name, std::string description): //only for SELECT result
        id_(id),
        name_(name),
        description_(description) {}

    TObjId id_; //don't touch; generated by db
    std::string name_;
    std::string description_; //optional atribute; set manually
};
struct CCZoneQuery
{
    CCZoneQuery():
       pId_(nullptr),
       pName_(nullptr),
       pDescription_(nullptr) {}

    CCZoneQuery(TObjId* pId, std::string* pName, std::string* pDescription):
       pId_(pId),
       pName_(pName),
       pDescription_(pDescription) {}

    TObjId* pId_;
    std::string* pName_;
    std::string* pDescription_;
};

struct CCZoneSOData
{
    CCZoneSOData(TObjId soId, TObjId ccZoneId):
        soId_(soId),
        ccZoneId_(ccZoneId) {}

    TObjId soId_;
    TObjId ccZoneId_;
};
struct CCZoneSOQuery
{
    CCZoneSOQuery():
        pSoId_(nullptr),
        pCCZoneId_(nullptr) {}

    CCZoneSOQuery(TObjId* pSoId, TObjId* pCCZoneId):
        pSoId_(pSoId),
        pCCZoneId_(pCCZoneId) {}

    TObjId* pSoId_;
    TObjId* pCCZoneId_;
};

struct DetectorData
{
    DetectorData():
        id_(0),
        vendor_("noname"), //value by default
        serialN_("sn") {} //value by default

    DetectorData(std::string vendor, std::string serialN):
        id_(0),
        vendor_(vendor),
        serialN_(serialN) {}

    DetectorData(TObjId id, std::string vendor, std::string serialN): //only for recieved data
        id_(id),
        vendor_(vendor),
        serialN_(serialN) {}

    TObjId id_; //generated by db
    std::string vendor_; //optional, set manually
    std::string serialN_; //optional, set manually
};
struct DetectorQuery
{
    DetectorQuery():
        pId_(nullptr),
        pVendor_(nullptr),
        pSerialN_(nullptr) {}

    DetectorQuery(TObjId* pId, std::string* pVendor, std::string* pSerialN):
        pId_(pId),
        pVendor_(pVendor),
        pSerialN_(pSerialN) {}

    TObjId* pId_;
    std::string* pVendor_;
    std::string* pSerialN_;
};

struct DistrictData
{
    explicit DistrictData(std::string name): //proper way to insert data to db
        id_(0),
        name_(name),
        description_("") {}

    DistrictData(std::string name, std::string description):
        name_(name),
        description_(description) {}

    DistrictData(TObjId id, std::string name, std::string description): //only for recieved from db data
        id_(id),
        name_(name),
        description_(description) {}

    TObjId id_; //generated by db
    std::string name_;
    std::string description_; //optional, set manually

};
struct DistrictQuery //to set options of query
{
    DistrictQuery(TObjId* pId, std::string* pName, std::string* pDescription):
        pId_(pId),
        pName_(pName),
        pDescription_(pDescription) {}

    DistrictQuery():
        pId_(nullptr),
        pName_(nullptr),
        pDescription_(nullptr) {}

    TObjId* pId_;
    std::string* pName_;
    std::string* pDescription_;
};

struct ErrorsSOData
{
    ErrorsSOData(time_t riseDatetime, std::string msg, TObjId soId) :
        id_(0),
        riseDatetime_(riseDatetime),
        msg_(msg),
        soId_(soId),
        fixDatetime_(NULL) {} 

    ErrorsSOData(time_t riseDatetime, std::string msg, TObjId soId, time_t fixDatetime) :
        id_(0),
        riseDatetime_(riseDatetime),
        msg_(msg),
        soId_(soId),
        fixDatetime_(fixDatetime) {}

    ErrorsSOData(TObjId id, time_t riseDatetime, std::string msg, TObjId soId,
                 time_t fixDatetime) : //use for resived data from db
        id_(id),
        riseDatetime_(riseDatetime),
        msg_(msg),
        soId_(soId),
        fixDatetime_(fixDatetime) {}

    TObjId id_; //not recommended to set value manually
    time_t riseDatetime_; //in db error_rise_datetime
    std::string msg_; //in db message
    TObjId soId_; //foreign key on SO
    time_t fixDatetime_; //in db error_fix_datetime
};
struct ErrorsSOQuery //to set options of query
{
    ErrorsSOQuery():
        pId_(nullptr),
        pRiseDatetimeStart_(nullptr),
        pRiseDatetimeEnd_(nullptr),
        pMsg_(nullptr),
        pSoId_(nullptr),
        pFixDatetimeStart_(nullptr),
        pFixDatetimeEnd_(nullptr) {}

    ErrorsSOQuery(TObjId* pId, time_t* pDatetimeRiseStart, time_t* pDatetimeRiseEnd,
                  std::string* pMsg, TObjId* pSoId, time_t* pDatetimeFixStart, time_t* pDatetimeFixEnd) :
        pId_(pId),
        pRiseDatetimeStart_(pDatetimeRiseStart),
        pRiseDatetimeEnd_(pDatetimeRiseEnd),
        pMsg_(pMsg),
        pSoId_(pSoId),
        pFixDatetimeStart_(pDatetimeFixStart),
        pFixDatetimeEnd_(pDatetimeFixEnd) {}

    TObjId* pId_;
    time_t* pRiseDatetimeStart_;
    time_t* pRiseDatetimeEnd_;
    std::string* pMsg_;
    TObjId* pSoId_;
    time_t* pFixDatetimeStart_;
    time_t* pFixDatetimeEnd_;
};

struct LogbookData
{
    LogbookData(TObjId soId, std::string entry)
        : soId_(soId)
        , entry_(entry) {}

    TObjId soId_;
    std::string entry_;
};

struct LogbookQuery
{
    LogbookQuery() {}
    LogbookQuery(TObjId* pSoId, std::string* pEntry)
        : pSoId_(pSoId)
        , pEntry_(pEntry) {}

    TObjId* pSoId_{ nullptr };
    std::string* pEntry_{ nullptr };
};

struct PhaseData
{
    PhaseData(TObjId soId, unsigned int numOnSO): //temporary: imgUri may be NULL
        soId_(soId),
        numOnSO_(numOnSO) {}

    PhaseData(TObjId soId, unsigned int numOnSO, std::string imgUri):
        soId_(soId),
        numOnSO_(numOnSO),
        imgUri_(imgUri){}

    TObjId soId_; //foreign key on SO
    unsigned int numOnSO_; //pk
    std::string imgUri_; //temporary set manually
};
struct PhaseQuery //to set options of query
{
    PhaseQuery():
        pSoId_(nullptr),
        pNumOnSO_(nullptr),
        pImgUri_(nullptr) {}

    PhaseQuery(TObjId* pSoId, unsigned int* pNumOnSO, std::string* pImgUri):
        pSoId_(pSoId),
        pNumOnSO_(pNumOnSO),
        pImgUri_(pImgUri) {}

    TObjId* pSoId_;
    unsigned int* pNumOnSO_;
    std::string* pImgUri_;
};

struct PlanData
{
    PlanData(TObjId soId, unsigned int numOnSO):
        soId_(soId),
        numOnSO_(numOnSO) {}

    PlanData(TObjId soId, unsigned int numOnSO, std::string description):
        soId_(soId),
        numOnSO_(numOnSO),
        description_(description){}

    TObjId soId_; //foreign key on SO
    unsigned int numOnSO_; //pk
    std::string description_; //optional; set manually
};
struct PlanQuery //to set options of query
{
    PlanQuery():
        pSoId_(nullptr),
        pNumOnSO_(nullptr),
        pDescription_(nullptr) {}

    PlanQuery(TObjId* pSoId, unsigned int* pNumOnSO, std::string* pDescription):
        pSoId_(pSoId),
        pNumOnSO_(pNumOnSO),
        pDescription_(pDescription) {}

    TObjId* pSoId_;
    unsigned int* pNumOnSO_;
    std::string* pDescription_;
};

struct PlanPhaseData
{
    PlanPhaseData(int soId, unsigned int planNum, unsigned int phaseNum,
                  unsigned int mainTime, unsigned int minTime, unsigned int maxTime):
        soId_(soId),
        planNum_(planNum),
        phaseNum_(phaseNum),
        mainTime_(mainTime),
        minTime_(minTime),
        maxTime_(maxTime) {}

    PlanPhaseData(int soId, unsigned int planNum, unsigned int phaseNum):
        soId_(soId),
        planNum_(planNum),
        phaseNum_(phaseNum) {}

    int soId_;
    unsigned int planNum_;
    unsigned int phaseNum_;
    unsigned int mainTime_; //optional
    unsigned int minTime_; //optional
    unsigned int maxTime_; //optional
};
struct PlanPhaseQuery
{
    PlanPhaseQuery():
        pSoId_(nullptr),
        pPlanNum_(nullptr),
        pPhaseNum_(nullptr),
        pMainTime_(nullptr),
        pMinTime_(nullptr),
        pMaxTime_(nullptr){}

    PlanPhaseQuery(unsigned int* pSoId, unsigned int* pPlanNum, unsigned int* pPhaseNum,
                  unsigned int* pMainTime, unsigned int* pMinTime, unsigned int* pMaxTime):
        pSoId_(pSoId),
        pPlanNum_(pPlanNum),
        pPhaseNum_(pPhaseNum),
        pMainTime_(pMainTime),
        pMinTime_(pMinTime),
        pMaxTime_(pMaxTime) {}

    unsigned int* pSoId_;
    unsigned int* pPlanNum_;
    unsigned int* pPhaseNum_;
    unsigned int* pMainTime_; //optional
    unsigned int* pMinTime_; //optional
    unsigned int* pMaxTime_; //optional
};

struct SOData
{
    SOData(std::string name, std::string ip, std::string address,
           std::string vendor, TObjId districtId, std::string latitude, std::string longitude):
    id_(0),
    name_(name),
    ip_(ip),
    address_(address),
    vendor_(vendor),
    passportUri_(""),
    districtId_(districtId),
    latitude_(latitude),
    longitude_(longitude) {}

    SOData(TObjId id, std::string name, std::string ip, std::string address,
           std::string vendor, std::string passportUri, TObjId districtId,
           std::string latitude, std::string longitude):
      id_(id),
      name_(name),
      ip_(ip),
      address_(address),
      vendor_(vendor),
      passportUri_(passportUri),
      districtId_(districtId),
      latitude_(latitude),
      longitude_(longitude) {}

    TObjId id_; //never set manually, generated by db
    std::string name_; //unique
    std::string ip_;
    std::string address_;
    std::string vendor_;
    std::string passportUri_; //optional atribut, set manually
    TObjId districtId_;
    std::string latitude_;
    std::string longitude_;
    bool operator<(const SOData& other) const { return ip_ < other.ip_; }
};
struct SOQuery //to set options of query
{
    SOQuery():
        pId_(nullptr),
        pName_(nullptr),
        pIp_(nullptr),
        pAdress_(nullptr),
        pVendor_(nullptr),
        pPassportUri_(nullptr),
        pDistrictId_(nullptr),
        pLatitude_(nullptr),
        pLongitude_(nullptr) {}

    SOQuery(TObjId* pId, std::string* pName, std::string* pIp, std::string* pAdress,
            std::string* pVendor, std::string* pPassportUri, TObjId* pDistrictId,
            std::string* pLatitude, std::string* pLongitude):
        pId_(pId),
        pName_(pName),
        pIp_(pIp),
        pAdress_(pAdress),
        pVendor_(pVendor),
        pPassportUri_(pPassportUri),
        pDistrictId_(pDistrictId),
        pLatitude_(pLatitude),
        pLongitude_(pLongitude)    {}


    TObjId* pId_;
    std::string* pName_;
    std::string* pIp_;
    std::string* pAdress_;
    std::string* pVendor_;
    std::string* pPassportUri_;
    TObjId* pDistrictId_;
    std::string* pLatitude_;
    std::string* pLongitude_;
};

struct SODetectorData
{
    SODetectorData(TObjId soId, unsigned int numOnSO, TObjId detectorId):
        soId_(soId),
        numOnSO_(numOnSO),
        detectorId_(detectorId) {}

    TObjId soId_; //foreign key on SO
    unsigned int numOnSO_;
    TObjId detectorId_; //foreidn key on Detector
};
struct SODetectorQuery
{
    SODetectorQuery():
        pSoId_(nullptr),
        pNumOnSO_(nullptr),
        pDetectorId_(nullptr) {}

    SODetectorQuery(TObjId* pSoId, unsigned int* pNumOnSO, TObjId* pDetectorId):
        pSoId_(pSoId),
        pNumOnSO_(pNumOnSO),
        pDetectorId_(pDetectorId) {}

    TObjId* pSoId_;
    unsigned int* pNumOnSO_;
    TObjId* pDetectorId_;

};

struct TrafficData
{
    TrafficData(time_t datetime, unsigned int data, TObjId soId, unsigned int detectorNum):
        id_(0),
        datetime_(datetime),
        data_(data),
        soId_(soId),
        detectorNum_(detectorNum) {}

    TrafficData(TObjId id, time_t datetime, unsigned int data, TObjId soId, unsigned int detectorNum):
        id_(id),
        datetime_(datetime),
        data_(data),
        soId_(soId),
        detectorNum_(detectorNum) {}

    TObjId id_; //don't touch; generated by db
    time_t datetime_;
    unsigned int data_;
    TObjId soId_;
    unsigned int detectorNum_;
};
struct TrafficQuery
{
    TrafficQuery():
        pId_(nullptr),
        pDatetimeStart_(nullptr),
        pDatetimeEnd_(nullptr),
        pData_(nullptr),
        pSoId_(nullptr),
        pDetectorNum_(nullptr) {}

    TrafficQuery(TObjId* pId, time_t* pDatetimeStart, time_t* pDatetimeEnd, unsigned int* pData,
                 TObjId* pSoId, unsigned int* pDetectorNum):
        pId_(pId),
        pDatetimeStart_(pDatetimeStart),
        pDatetimeEnd_(pDatetimeEnd),
        pData_(pData),
        pSoId_(pSoId),
        pDetectorNum_(pDetectorNum) {}

    TObjId* pId_;
    time_t* pDatetimeStart_;
    time_t* pDatetimeEnd_;
    unsigned int* pData_;
    TObjId* pSoId_;
    unsigned int* pDetectorNum_;
};

struct UserData
{
    UserData(std::string userName, std::string pwd, UserLevel lvl): //safe insert into db
        id_(0),
        userName_(userName),
        pwd_(pwd),
        lvl_(lvl) {}

    UserData(TObjId id, std::string userName, std::string pwd, UserLevel lvl): //use this only for recieved data
        id_(id),
        userName_(userName),
        pwd_(pwd),
        lvl_(lvl) {}

    TObjId id_;
    std::string userName_; //UNIQUE
    std::string pwd_;
    UserLevel lvl_; //int in db
};
struct UserQuery //to set options of query
{
    UserQuery(TObjId* pId, std::string* pUserName, std::string* pPwd,
              UserLevel* pLvl):
        pId_(pId),
        pUserName_(pUserName),
        pPwd_(pPwd),
        pLvl_(pLvl) {}

    UserQuery():
        pId_(nullptr),
        pUserName_(nullptr),
        pPwd_(nullptr),
        pLvl_(nullptr) {}

    TObjId* pId_;
    std::string* pUserName_; //UNIQUE
    std::string* pPwd_;
    UserLevel* pLvl_; //int in db
};

struct UserLogData
{
    UserLogData(time_t logDatetime,  std::string action, TObjId userId): //request safe
        id_(0),
        logDatetime_(logDatetime),
        action_(action),
        userId_(userId) {}

    UserLogData(TObjId id, time_t logDatetime, std::string action, TObjId userId): //only for recieved data
        id_(id),
        logDatetime_(logDatetime),
        action_(action),
        userId_(userId) {}

    TObjId id_; //generated by db; do not touch
    time_t logDatetime_;
    std::string action_;
    TObjId userId_; //foreign key on Users
};
struct UserLogQuery
{
    UserLogQuery():
        pId_(nullptr),
        pLogDatetimeStart_(nullptr),
        pLogDatetimeEnd_(nullptr),
        pAction_(nullptr),
        pUserId_(nullptr) {}

    UserLogQuery(TObjId* pId, time_t* pLogDatetimeStart, time_t* pLogDatetimeEnd,
                 std::string* pAction, TObjId* pUserId):
        pId_(pId),
        pLogDatetimeStart_(pLogDatetimeStart),
        pLogDatetimeEnd_(pLogDatetimeEnd),
        pAction_(pAction),
        pUserId_(pUserId) {}

    TObjId* pId_;
    time_t* pLogDatetimeStart_;
    time_t* pLogDatetimeEnd_;
    std::string* pAction_;
    TObjId* pUserId_;
};
}  //namespace db
